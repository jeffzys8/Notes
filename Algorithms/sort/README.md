# 排序算法
- [排序演示视频](https://www.cnblogs.com/Alexr/p/9940667.html)
- 《算法》(第四版)
> 这里都以从小到大排序为例

## 初级方法

### 选择排序

通过n-i次关键字之间的比较,从n-i+1 个记录中选择关键字最小的记录,并和第i(1<=i<=n)个记录交换之（性能略优于选择排序）

### 插入排序

把第i位插入到前面i-1位中，前面不用动，后面全都后移一位。插入排序对于部分有序的数组十分高效， 也很适合小规模数组

### 冒泡排序

两两比较，把更大的从前往后挪（或者把最小的从后往前挪）


## 希尔排序

先将整个待排元素序列分割成若干子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序（增量为1）。其时间复杂度为O(n^3/2),要好于直接插入排序的O(n^2)

> 希尔排序的性能未被完全了解！

排序之初，各个子数组都很短，排序之后子数组都是部分有序的， 这两种情况都很适合插入排序。

https://www.cnblogs.com/chengxiao/p/6104371.html

## 归并排序

递归, 时间复杂度O(NlogN), 但空间复杂度是O(N)

原地归并实现复杂，但可以将归并操作抽象为一个函数（当然函数执行过程中还是要有临时变量的）

自顶向下的归并

自底向上的归并

### 快速排序

应用最广泛，理论O(NlogN)，最差O(N^2)；说起来很简单，但实现起来稍微复杂一些：就是每次随机选定一个pivot，然后分为一左一右，再接着分治着去排序。

对于小数组，快速排序比插入排序慢。所以可以采取对小数组进行插入排序的方法来优化代码。

> 刷道题试试

```Go
// 主要是临界条件难处理，写下来背一下
func partition(list []int) {
    if len(list) <= 1 {
        return
    }

    l := 0
    r := len(list)
    pivot := list[l] // 以list首为轴
    for{
        l++
        for list[l] < pivot{
            if l == len(list) -1 {
                break
            }
        }
        r--
        for pivot < list[r]{
            if r == 0 {
                break
            }
        }
        if l >= r {
            break
        }
        list[l], list[r] = list[r], list[l]
    }
    list[0], list[r] = list[r], list[0]
}
```

## 优先队列和堆排序

- [堆排序(感觉讲的最好的一个了)](https://blog.csdn.net/u013384984/article/details/79496052)

> 但还是书讲得好~从优先队列入手

**优先队列**

二叉堆：是一个完全二叉树做成的堆（因此有父节点=k/2，子节点=2k, 2k+1的性质）(不使用数组的第一个位置？？ why)

- 由下至上的堆有序化 swim; 加入新节点/某个节点优先级上升（某个节点<父节点）; 向上冒泡
- 由上至下的堆有序化 sink; 某个节点大于其子节点了; 向下沉底

操作：
- 插入元素: 数组插入新值并不断 swim; (直接父子交换)
- pop最优(顶): 删去顶并将尾放到顶并不断 sink; (记得sink是要兄弟节点比一下的)

还可以变成多叉堆（不知道有没有什么效率上的优势呢）


**堆排序**

- 构造最小堆(以从小到大排序为例) 构成优先队列
  - 方法一：从左到右不断swim
  - 方法二：从右往左不断sink (更高效，因为我们从N/2开始就行了，叶子节点不用sink)
- 不断pop最优，同时缩短优先队列

比较次数: 2NlogN + 2N (最多); 交换次数减半
复杂度即O(NlogN)

[topK问题](top-k.md)