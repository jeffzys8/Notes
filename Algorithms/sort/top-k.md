# top-k

问题就是在海量数据中选取头k个数（这里以大到小排序）

## 全排序

数据量较小的时候可以做，但大数据量就很不适合了

## 快排变形

需要内存够

本质就是找到某个pivot，其值使得刚好>=的刚好有K个数（当然要注意一下重复的数这样的边界条件）

随机选择一个pivot，左大右小划分，然后根据左半区长度> < = K决定是否停下 or 往左划分 or 往右划分，当然要做一些值的更替：比如

```
某次划分后: [(K-n)个数, m个数]
此时需要往[right]继续分区
则我们期待的停止条件是 [K-n , [n,  ]] 右边不是K了，是n了

同理某次划分后: [(K+n)个数, m个数]
此时需要往[left]继续分区
则我们期待的停止条件仍然是 [K, ] 
```

## 最小堆

> 单机感觉是最好的操作了

先读取前K个数，建立一个最小堆（小的数在上面，大的数在下面），之后将剩余的数依次和堆顶作比较，如果小于堆顶丢弃，大于堆顶则将该数替换堆顶并执行sink操作(见[排序归纳](README.md))

## 分治

将所有数据分成N份，找出每份数据中的top-K（比如分成最小堆），然后最后再统一比较。

## 哈希

如果数据很有多重复，可以先用hash将重复的数去掉(这个读不进内存怎么办)。