# Chapter 2 - Data Representation

> 这章基本是复习，所以就过的很随意了

二进制更容易用于机器表示

将要学习三种数字表示法:
- Unsigned
- Two's-complement 二进制补码
- Floating-point

## 数据的存储

计算机通常以 Bytes 为内存取址的 最小单位

**Chapter9** 会介绍虚拟内存的实现 —— 将物理内存、硬盘、操作系统抽象为一个单一的字节数组空间(虚拟地址空间)；现在这几章先讲编译器和运行时怎么使用虚拟地址空间

尽管C语言有类型，编译成机器语言就没了，就是不同大小的Bytes的存取

16进制中1byte范围: `[00, FF]`

Words字:
- 指示 int / pointer 的大小
- 指示 虚拟地址空间 的大小
- 通常为 32-bit / 64-bit

C 数据类型(byte为单位):
|类型|32-bit|64-bit|
|--|--|--|
|char|1|1
|short (int)|2|2
|int |4|4
|long (int)|4|8
|long long (int)|8|8
|**char \***|4 | 8
|float|4|4
|double|8|8
- `long` = word size
-  上面`char*`代指所有指针 = word size

> 32位迁移64位会有什么问题? 书中给出一个例子: int当指针用, 32位没问题, 64位有问题

大小端(同见[网络笔记](../../Network/high-per-serv/basic-api/socket-addr.md)):
- 小端little endian: 高位byte占高地址
  - **Intel机器大多使用小端**
- 大端big endian: 高位byte占低地址
  - **网络字节序**
  - **Chapter11**还会讲到
- 反汇编指令(小端)
```
80483bd:    01 05 64 94 04 08     add %eax,0x8049464
```

`sizeof`返回数据类型的字节数

Java使用Unicode编码字符串; Go呢？

布尔代数

C的位运算
- 竟然有 `~` 操作符，表示二进制取反..
- 逻辑右移和算数右移
  - 左移只有一种，就是低位补0
  - 逻辑右移就是高位补0
  - 算术右移用最高位填充(比如负数就全是1了) **通常都是算术右移**


## 整数表示

> 将会学习两种整数的二进制编码:无符号、有符号; 同样也会学习整数的类型转换

看起来C的各种整数数据类型只有 `long` 会在32位和64位中值范围不同: 都是取机器的一个字

**无符号表示法**编码就是普通的二进制表示法

**补码**编码
- 取二进制最高位表示符号
- 公式一言蔽之: $B2T_w(\vec x)=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$
- 举例
  - $B2T_4([0101])=-0\times2^3+1\times2^2+0\times2^1+1\times2^0=5$
  - $B2T_4([1011])=-1\times2^3+0\times2^2+1\times2^1+1\times2^0=-5$
  - > 这里其实自己就能看出来刚好 ±5 正好是 **取反+1** 的关系，两者相加去掉溢出又刚好为0
  - > 但有个边界例子 [1000] 取反+1仍是 [1000]
- 取值范围: $[-2^{w-1}, 2^{w-1}-1]$
  - 比如上面例子中的4位就是 $[-8, 7]$

反码和符号位编码都是过时的，就不提了，而且取值范围都比补码少了一位

## 整数类型转换

4位 有符号整数(补码) 和 无符号整数的对应关系
```
-8 --> 1000 --> 8
-7 --> 1001 --> 9
-6 --> 1010 --> 10
-5 --> 1011 --> 11
-4 --> 1100 --> 12
-3 --> 1101 --> 13
-2 --> 1110 --> 14
-1 --> 1111 --> 15
0 --> 0000 --> 0
1 --> 0001 --> 1
2 --> 0010 --> 2
3 --> 0011 --> 3
4 --> 0100 --> 4
5 --> 0101 --> 5
6 --> 0110 --> 6
7 --> 0111 --> 7
```
> 从这里可以看出两者的相互转化方式是挺明显的，所以在实现C的隐式转化时就很简单了

有符号和无符号计算会被转成无符号，然后再做bool操作(见Problem 2.21)

从小的数据类型转大的数据类型:
- 无符号直接补零
- 有符号补最高位
- **有符号转无符号：先转bit，再转sign(C标准定义)**，反过来的话结果是不同的

从大的数据类型转小的数据类型:
- 直接丢弃高位

应该用 `i < len` 代替 `i <= len-1`以避免溢出bug: 
```c
float sum_elements(float a[], unsigned length) 
{
  int i;
  float result = 0;
  for (i = 0; i <= length-1; i++)
    result += a[i];
  return result;
}
```

应该用 `a > b` 而不是 `a - b > 0`:
```c
int strlonger(char *s, char *t) {
  return strlen(s) - strlen(t) > 0;
}
```

> 有意思的观点..一种避免符号类型导致错误是干脆编译器不支持无符号整数

## 整数计算

无符号加法判断是否溢出:
```c
int uadd_ok(unsigned x, unsigned y) {
	unsigned result = x + y;
	return result >= x;
}
```

> 溢出这一节有不少数学环节都略去了，其实可以补一下的。特别是有符号的negative overflow 和 positive overflow; 还有阿贝尔群的概念?

有符号加法判断是否溢出:
```c
int tadd_ok(int x, int y) {
	int sum = x+y;
	if(x < 0 && y < 0 && sum >= 0) {
		return 0;
	}
	if(x > 0 && y > 0 && sum < 0) {
		return 0;
	}
	return 1;
}
```

有符号减法判断是否溢出:
- 不能直接 `tadd_ok(x, -y)`
- 比如 `y = TMin = -2^32`, `-y = -2^32 = y`，且`x<0`; 这时候 `x-y`永远会被判断为溢出(实际上不会)
  ```
  // 挺神奇的，比如取 w = 4,
  x = 1001 = -7
  y = 1000 = -8
  x - y = x + (-y) = x + y = 0001
  // 按位减法也同样是这个结果, 数学真奇妙
  ```
- **这说明`TMin`是一个测试时候要考虑的重要边界**， 所以修改后的程序只要在第一个条件里加上判断是否其中一个为`TMin`即可


无符号乘法
- $(x\cdot y) mod 2^{w}$
- 就是二进制的按位乘，但比较好奇处理器是怎么算的?

有符号乘法
- $U2T_{w}((x\cdot y) mod 2^{w})$
- 就是在无符号乘法的基础上做一下表示的转换

> problem 2.35 证明 `tmul_ok` 函数正确性跳过了; 暂时不想看数学证明

在大多数机器上，乘法会比较慢，需要10+个时钟周期(其他二进制操作基本只需要一个)，因此编译器会尝试 **将整数乘法转换为加法+移位**
- 对于 $x\times2^k$，直接移位即可
- 对于 $x\times14$, 由于 $14=2^3+2^2+2^1$，可优化为`(x<<3)+(x<<2)+(x<<1)`
- 另一种优化(更好), 由于 $14=2^4-2^1$, `(x<<4)-(x<<1)`

整数除法比乘法还慢，需要30+个时钟周期

有符号数除以2的k次幂并向下取整
- 这导致负数异常，比如 -5/2 = -3，是向负数取整的
- [x/y]upper = [(x+y-1)/y]lower 
  - 有点数学，2.3.7有证明(设x=ky+r，注意4也是整数!)
- 但反正负数使用偏移量去算除法，就能保持往0取整
- **但任意整数除法无法像乘法那样优化**
```c
// 适用于有符号数除2的k次幂
(x<0 ? x+(1<<k)-1 : x) >> k
```

有意思的题目: 不能使用取模、乘法、条件判断计算 `int div16(int x)`
```c
int div16(int x) {
  // 利用负数最高位为1
  int bias = (x >> 31) & 15;
  return (x + 15) >> 4;
}
```
**Problem 2.44 值得经常温习，判断TrueFalse，概括了一些整数计算的边界条件**

## 浮点数表示