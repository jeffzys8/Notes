# Chapter 2 - Data Representation

> 这章基本是复习，所以就过的很随意了

二进制更容易用于机器表示

将要学习三种数字表示法:
- Unsigned
- Two's-complement 二进制补码
- Floating-point

## 数据的存储

计算机通常以 Bytes 为内存取址的 最小单位

**Chapter9** 会介绍虚拟内存的实现 —— 将物理内存、硬盘、操作系统抽象为一个单一的字节数组空间(虚拟地址空间)；现在这几章先讲编译器和运行时怎么使用虚拟地址空间

尽管C语言有类型，编译成机器语言就没了，就是不同大小的Bytes的存取

16进制中1byte范围: `[00, FF]`

Words字:
- 指示 int / pointer 的大小
- 指示 虚拟地址空间 的大小
- 通常为 32-bit / 64-bit

C 数据类型(byte为单位):
|类型|32-bit|64-bit|
|--|--|--|
|char|1|1
|short (int)|2|2
|int |4|4
|long (int)|4|8
|long long (int)|8|8
|**char \***|4 | 8
|float|4|4
|double|8|8
- `long` = word size
-  上面`char*`代指所有指针 = word size

> 32位迁移64位会有什么问题? 书中给出一个例子: int当指针用, 32位没问题, 64位有问题

大小端(同见[网络笔记](../../Network/high-per-serv/basic-api/socket-addr.md)):
- 小端little endian: 高位byte占高地址
  - **Intel机器大多使用小端**
- 大端big endian: 高位byte占低地址
  - **网络字节序**
  - **Chapter11**还会讲到
- 反汇编指令(小端)
```
80483bd:    01 05 64 94 04 08     add %eax,0x8049464
```

`sizeof`返回数据类型的字节数

Java使用Unicode编码字符串; Go呢？

布尔代数

C的位运算
- 竟然有 `~` 操作符，表示二进制取反..
- 逻辑右移和算数右移
  - 左移只有一种，就是低位补0
  - 逻辑右移就是高位补0
  - 算术右移用最高位填充(比如负数就全是1了) **通常都是算术右移**


## 整数表示

> 将会学习两种整数的二进制编码:无符号、有符号; 同样也会学习整数的类型转换

看起来C的各种整数数据类型只有 `long` 会在32位和64位中值范围不同: 都是取机器的一个字

**无符号表示法**编码就是普通的二进制表示法

**补码**编码
- 取二进制最高位表示符号
- 公式一言蔽之: $B2T_w(\vec x)=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$
- 举例
  - $B2T_4([0101])=-0\times2^3+1\times2^2+0\times2^1+1\times2^0=5$
  - $B2T_4([1011])=-1\times2^3+0\times2^2+1\times2^1+1\times2^0=-5$
  - > 这里其实自己就能看出来刚好 ±5 正好是 **取反+1** 的关系，两者相加去掉溢出又刚好为0
  - > 但有个边界例子 [1000] 取反+1仍是 [1000]
- 取值范围: $[-2^{w-1}, 2^{w-1}-1]$
  - 比如上面例子中的4位就是 $[-8, 7]$

反码和符号位编码都是过时的，就不提了，而且取值范围都比补码少了一位

## 整数类型转换

4位 有符号整数(补码) 和 无符号整数的对应关系
```
-8 --> 1000 --> 8
-7 --> 1001 --> 9
-6 --> 1010 --> 10
-5 --> 1011 --> 11
-4 --> 1100 --> 12
-3 --> 1101 --> 13
-2 --> 1110 --> 14
-1 --> 1111 --> 15
0 --> 0000 --> 0
1 --> 0001 --> 1
2 --> 0010 --> 2
3 --> 0011 --> 3
4 --> 0100 --> 4
5 --> 0101 --> 5
6 --> 0110 --> 6
7 --> 0111 --> 7
```
> 从这里可以看出两者的相互转化方式是挺明显的，所以在实现C的隐式转化时就很简单了

当有符号数和无符号数同时进行计算，有符号会被转成无符号，然后都以无符号的形式参与计算(比如Problem 2.21，因为计算符号的改变而产生了“反直觉”的答案)

从小的数据类型转大的数据类型:
- 无符号直接补零
- 有符号补最高位
- **有符号转无符号：先补高位bit，再转符号表示(C标准定义)**
- 无符号转有符号同理：先补零，然后用有符号来表示(此时肯定是正数，因为首位肯定为0)

```C
// 举例: 小有符号 --> 大无符号
short sx = -12345; // bit: cf c7
unsigned uy = sx; // bit: ff ff cf c7
// 也即 uy = (unsigned) (int) sx;
// 而非 uy = (unsigned) (unsigned short) sx;
```

从大的数据类型转小的数据类型:
- 直接丢弃高位

应该用 `i < len` 代替 `i <= len-1`以避免溢出bug: 
```c
// 如果传入 length == 0 就会出现数组越界
float sum_elements(float a[], unsigned length) 
{
  int i;
  float result = 0;
  for (i = 0; i <= length-1; i++)
    result += a[i];
  return result;
}
```

应该用 `a > b` 而不是 `a - b > 0`:
```c
int strlonger(char *s, char *t) {
  return strlen(s) - strlen(t) > 0;
}
```

> 有意思的观点..一种避免符号类型导致错误是干脆编译器不支持无符号整数

## 整数计算

无符号加法判断是否溢出:
```c
int uadd_ok(unsigned x, unsigned y) {
	unsigned result = x + y;
	return result >= x;
}
```

> 溢出这一节有不少数学环节都略去了，其实可以补一下的。特别是有符号的negative overflow 和 positive overflow; 还有阿贝尔群的概念?

有符号加法判断是否溢出:
```c
int tadd_ok(int x, int y) {
	int sum = x+y;
	if(x < 0 && y < 0 && sum >= 0) {
		return 0;
	}
	if(x > 0 && y > 0 && sum < 0) {
		return 0;
	}
	return 1;
}
```

有符号减法判断是否溢出:
- 不能直接 `tadd_ok(x, -y)`
- 比如 `y = TMin = -2^32`, `-y = -2^32 = y`，且`x<0`; 这时候 `x-y`永远会被判断为溢出(实际上不会)
  ```
  // 挺神奇的，比如取 w = 4,
  x = 1001 = -7
  y = 1000 = -8
  x - y = x + (-y) = x + y = 0001
  // 按位减法也同样是这个结果, 数学真奇妙
  ```
- **这说明`TMin`是一个测试时候要考虑的重要边界**， 所以修改后的程序只要在第一个条件里加上判断是否其中一个为`TMin`即可


无符号乘法
- $(x\cdot y) mod 2^{w}$
- 就是二进制的按位乘，但比较好奇处理器是怎么算的?

有符号乘法
- $U2T_{w}((x\cdot y) mod 2^{w})$
- 就是在无符号乘法的基础上做一下表示的转换

> problem 2.35 证明 `tmul_ok` 函数正确性跳过了; 暂时不想看数学证明

在大多数机器上，乘法会比较慢，需要10+个时钟周期(其他二进制操作基本只需要一个)，因此编译器会尝试 **将整数乘法转换为加法+移位**
- 对于 $x\times2^k$，直接移位即可
- 对于 $x\times14$, 由于 $14=2^3+2^2+2^1$，可优化为`(x<<3)+(x<<2)+(x<<1)`
- 另一种优化(更好), 由于 $14=2^4-2^1$, `(x<<4)-(x<<1)`

整数除法比乘法还慢，需要30+个时钟周期

有符号数除以2的k次幂并向下取整
- 这导致负数异常，比如 -5/2 = -3，是向负数取整的
- [x/y]upper = [(x+y-1)/y]lower 
  - 有点数学，2.3.7有证明(设x=ky+r，注意4也是整数!)
- 但反正负数使用偏移量去算除法，就能保持往0取整
- **但任意整数除法无法像乘法那样优化**
```c
// 适用于有符号数除2的k次幂
(x<0 ? x+(1<<k)-1 : x) >> k
```

有意思的题目: 不能使用取模、乘法、条件判断计算 `int div16(int x)`
```c
int div16(int x) {
  // 利用负数最高位为1
  int bias = (x >> 31) & 15;
  return (x + 15) >> 4;
}
```
**Problem 2.44 值得经常温习，判断TrueFalse，概括了一些整数计算的边界条件**

## 浮点数表示

将有理数表示为 $V=x\times 2^y$

二进制表示带分数的数，就是用小数点，小数点右边即 $2^{-n}$
- $101.11_2=4+1+\frac{1}{2}+\frac{1}{4}=5\frac{3}{4}$

> 十进制转二进制公式是什么

**IEEE754**: 浮点数表示和计算的工业事实标准

$V=(-1)^s \times M \times 2^E$ (以float为例)
- $(-1)^s$ 决定符号位(s)，s取0或1；占1位
- $2^E$即指数位(exp)，E是任意整数；占8位 (double = 11)
- M是二进制分数(frac)，$M\in[0,1) or [1,2)$；占23位 (double = 52)

三种表示情况
1. 正规值
   - **exp不全为0，也不全为1**
   - $E=exp-Bias, Bias=2^{k-1}-1$ Bias(float=127, double=1023) 
   - 有Bias就能表示负指数了，这样指数范围
     - $E_{float}\in [-126,127]$
     - $E_{double}\in [-1022,1023]$
     - 和int32/64不一样，是负数少一位，且左右各少一位(exp不全为0也不全为1)
   - frac 表示 $1.f_{n-1}....f_1f_0$，即$M=1+f$
     - 开头的1不占空间，白嫖1位
     - 因此用frac表示的M有 $M\in[1,2)$
   - 易得正规V取值范围 $V_{float}\in[-(2-2^{-23})\cdot 2^{127}, -2^{-126}]\cup[2^{-126}, (2-2^{-23})\cdot 2^{127}]$
2. 非正规值
   - **exp全为0**
   - $M=f$，即$M\in[0,1)$
   - $E=1-Bias$, 即float=-126, double=-1022 
     - 竟然不是 $-Bias$ ,有点违反直觉，但 -126 和上面正规值取值范围一比就“连续”上了!
   - 可同时表示 +0.0 和 -0.0
   - 可表示正规值表示不了的，非常接近0的数
   - 易得非正规V取值范围 $V_{float}\in [-(1-2^{23})\cdot 2^{-126}, (1-2^{23})\cdot 2^{-126}]$
3. 特殊值
   - **exp全为1**
   - $s=0, V=+\infty$
   - $s=1, V=-\infty$
   - 可用于表示溢出，比如两个很大的数相乘，或者除以0 (NaN)

IEEE表示的浮点数的二进制排列是有序的，即二进制升序，所表示浮点数也升序

> TODO: 一些重要值 page109

> TODO: problem 2.49回看一下

Rounding：寻找实数的近似机器表示
- round-to-even(或叫round-to-nearest, 默认做法)
  - 不遵循传统四舍五入，而是使最低有效位为偶数
  - 对于当样本随机数，四舍五入会使整体数据平均值偏高
  - 对于二进制而言，就是在需要舍入时选择最低位为0
  - 二进制这种情况只有 `xxxx.yyy100....`, 其中最右边的y为可表示的最低位
- round-toward-zero
- round-down
- round-up

Problem 2.52 最后一题是从非正规值转成了正规值

## 浮点数计算

- 加法满足交换律，不满足结合律
  - $(3.14+1e10)-1e10 = 0.0$
- 乘法同样满足交换律，不满足结合律，也不满足分配律
  - $(1e20*1e20)*1e-20 = +\infty$
  - $1e20*(1e20-1e20)=0.0$, 但 $1e20*1e20-1e20*1e20e = NaN$

## C语言中的浮点数

C语言标准不规定使用IEEE浮点数，因此标准中无法表示 -0.±∞, Nan;


gcc编译器定义  `INFINITY` 和 `NAN` 常量
```c
#define _GNU_SOURCE 1
#include <math.h>
```