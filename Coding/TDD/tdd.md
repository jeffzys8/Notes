# 测试驱动开发 

先设计理想的接口调用, 写个test; 然后写上只能通过编译但不能测试通过的伪实现; 逐步通过fake和mock实现这个接口.

在测试通过以后, 消除冗余; 冗余是代码耦合的表现, 也是导致bug的一个原因.

在冗余消除以后才可以从todo-list中消除某个待办事项

TODO-list
为发现的缺陷先写下一个test, 然后再解决它

补全所发现缺失的测试, 否则重构就会在不经意间出问题; 重构应该是基于已有测试的代码, 否则就是重写了.

解耦用户代码对子类的可见性，在父类创建工厂函数来解耦

> 为啥这么执着于去掉币种子类..是因为子类的很多逻辑相同所以要去掉是吗..确实是这样, 如果保留子类意味着每加入一种货币就要引入一堆重复代码

在有测试规定程序预期行为的前提下, 如果不确定实现或者重构(消除冗余)具体该怎么做, 可以不断缩小编码步骤让测试逐渐可运行, 在思路更加明确以后再做更大的改动. TDD给予开发者选择基于更小步骤开发的控制权

> 实现加法这里感觉作者有点跳, 先搬出来 `Expression interface`, 然后才去实现 `Sum`, `Money` 的 `reduce()`; 如果真按照TDD, 我觉得第一步应该还是先实现出 `Money` 的 `reduce`, 然后去通过新的测试引导出 `Sum` 这个类以及其 `reduce`, 然后再抽象出一个`Expression`接口来去除`Money`和`Sum`之间的冗余。最后才是出现`Bank`这个对象来参与`reduce`操作，接受`Expression`接口来统一处理

圈复杂度

设计模式
插入式对象, 插入式选择器
**递归组合模式**, 会和现实的对象概念有所偏离, 但对于简化代码很有帮助

内联方法来看看多层抽象以后到底调用了什么, 以免往错误的方向去重构