# Go包/模块管理

## 原生

**包的导入**

通常一个包所在目录路径的后缀是包的导入路径；例如包`gopl.io/ch1/helloworld`对应的目录路径是`$GOPATH/src/gopl.io/ch1/helloworld`

每个源文件都是以包的声明语句开始，用来指明包的名字

包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的

包级别的名字，例如在一个文件声明的类型和常量，在同一个包的其他源文件也是可以直接访问的，**就好像所有代码都在一个文件一样**

在Go语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似"gopl.io/ch2/tempconv"的字符串对应包的导入路径。Go语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时（第十章），一个导入路径代表一个目录中的一个或多个Go源文件。

按照惯例，一个包的名字和包的导入路径的最后一个字段相同

在默认情况下，导入的包绑定到包声明语句指定的名字（比如导入`gopl.io/ch2/tempconv`则包名绑定到`tempconv`），然后通过该短小的名字就可以引用包中导出的全部内容。但是我们也可以绑定到另一个名称，以避免名字冲突（§10.4）。

**包的初始化**

`init()`初始化函数

每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次

因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。


**编译速度**

Go语言的闪电般的编译速度主要得益于三个语言特性。
- 第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。
- 第二点，**禁止包的环状依赖**，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。
- 第三点，编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件（译注：很多都是重复的间接依赖）。

## go module