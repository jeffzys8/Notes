# tcp

> [TCP/IP 详解(卷一)](http://www.52im.net/topic-tcpipvol1.html)

主要包含四个内容
- tcp header
- 状态转移方程
- 数据流 (?) 交互数据流、成块数据流、*紧急数据
- 数据流控制 - 超时重传、拥塞控制

## tcp服务特点

相对于udp: 
- 面向连接：tcp是一对一连接，不适合广播和多播，udp适合
- 字节流：发送端写次数 与 接收端读次数 无数量关系（数据无边界）。
- 可靠传输：发送ack，超时重传，数据排序


## header

- 16位src port, 16位dst port
- 32位seq; 初始值为某个随机值; 标识数据offset (看起来4GB数据以后又会从头)
- 32位ack; 值为收到的seq+1 (**不是seq+len+1吗??**)
- 4位header长度，最长为60bytes
- 6位标志位
  - URG 紧急指针是否有效
  - ACK 
  - PSH 提示接收端立即读走数据
  - RST 要求对方重连(复位报文段)
  - SYN
  - FIN
- 16位window size，流量控制
- 16位校验和，**校验整个TCP数据报**
- 16位紧急指针 (指针+seq = 最后一个紧急数据序号+1)，(**紧急数据有啥用**)
- <=40bytes的option(20bytes是前面的固定,因此option最大为60-20=40bytes)
  - 好多用途...
  - kind=2, 协商最大报文段，一般设为 MTU-40 = 1460，防止IP分片
  - kind=3, 窗口扩大因子，用位移，就很大.. `/proc/sys/net/ipv4/tcp_window_scaling`
  - kind=4, 选择确认(SACK)选项，用于选择重传，不必发送丢失seq后续所有的包, `/proc/sys/net/ipv4/tcp_sack`
  - kind=5, SACK实际工作选项，接收端告诉发送端已经收到并cached的不连续数据块

3.2.3 tcpdump 抓包tcp

## tcp连接的建立和关闭

3.3.1 tcpdump抓包看连接过程(telnet)

三次握手
- SYN包第一个seq占用一个字节，因此返回的ack为seq+1，后面则就是真实数据的偏移了
- 超时重连策略，3.3.3抓包，每次超时重连时间翻倍知道5次(32s)

四次挥手
- 被动方的第一次ack居然是可以省略的，因为被动方的FIN也包括了ack，这取决于**延迟确认**特性(没听说过)
- 半关闭状态，即FIN指示完成数据发送，但对端仍会发送数据过来直到对面也发FIN；应用程序判断对方是否已关闭: `read`系统调用返回0即结束；Linux还提供了别的方法检测关闭。**虽然介绍了半关闭状态，但是使用它的很少见**

## 状态转移方程

> 略过 TODO 补充图

TIME_WAIT: 第三次挥手(主动FIN方收到FIN时)后，并不是直接进入CLOSED，而是转移到TIME_WAIT, 要等待一个2MSL(Maximum Segment Life)的时间，一般是2min。TIME_WAIT存在两个原因：
- 保证可靠断开连接(最后一个ACK被被动方有效接收)
- 防止后续的连接接收到上一个连接未发完的消息
但有时候需要避免TIME_WAIT，毕竟那个端口就2MSL不可用了。服务器会更需要避免这个问题。socket选项`SO_REUSEADR`可以强制进程立即使用处于TIME_WAIT状态的端口

## 复位报文段

> 暂时略过，处理几种异常情况。

## 交互、成块数据流

交互数据仅包含很少字节，使用的应用程序对实时性比较高(telnet, ssh)
成块数据一般就占满整个TCP报文段最大长度(MTU-40=1460bytes)，对传输效率高(ftp)

3.6，3.7分别对交互数据流、成块数据流进行tcpdump抓包，回头可以好好看看~还包括了修改发送缓冲区大小，操作有点厉害

## 带外数据

> 略过，OOB数据，优先级高；利用头部的紧急指针和紧急指针标志。

## 超时重传

每个TCP报文段都维护了一个定时器

iperf是个测量网络状况的工具，这里用来当一个数据黑洞；默认监听5001端口。

TCP超时重传也是每次超时时间翻倍(类似超时重连策略)，5次失败后IP和ARP接管(这啥意思)，直至放弃连接。

- `/proc/sys/net/ipv4/tcp_retries1` 指示底层协议(IP, ARP)接管前的最少重传次数
- `/proc/sys/net/ipv4/tcp_retries2` 指示放弃重传前TCP最多可以执行的重传次数

> 这里文章感觉有点问题 (3.9)，怎么就坚持连接的时间是15min了？？看抓包也就几秒时间

## 拥塞控制

拥塞控制，提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性。多种算法，reno, vegas, cubic;
`/proc/sys/net/ipv4/tcp_congestion_control`文件控制当前算法

**拥塞窗口(CWND)对方的接受窗口(RWND)中的最小值决定了发送窗口(SWND)**，即发送端向网络一次连续写入的数据量。这个值限制的是报文数，而每个报文的最大值一般=MSS(1460bytes)(后面用**SMSS**描述)

**慢启动**
- TCP建立时初始化CWND为较小值IW, 也即一开始一次性最多能发送IW字节数据(2~4 SMSS字节，新Linux更多)
- 在接收到ACK时，CWND += min(N, SMSS)，差不多就是一个ACK就+1报文大小。比如一开始是2，收到两个确认后下次就发4。**整体呈指数型增长**

**拥塞避免**
- 慢启动一点都不慢...CWND超过慢启动门限(ssthresh)时，会进入拥塞避免，此时CWND按线性增长。两种实现方式：
  - 每个RTT +1，而不是RTT内+n(ack数)
  - CWND += SMSS* SMSS/CWND

以上都是在未发生拥塞时拥塞控制的行为。
判断拥塞发生的依据：
1. 传输超时
2. 接收到3个重复的确认报文段

对于第一种情况，会直接走慢启动并调整慢启动门限(ssthresh): ssthresh = max(FlightSize/2, 2*SMSS), CWND <= SMSS。其中FlightSize是已经发送但未收到确认的字节数

> 我理解有点相当于原来的ssthresh减半

对于第二种情况，有很多种情况会遇到重复的ack，比如TCP报文段丢失，接收到乱序TCP报文段...为了确认TCP报文段真的丢失了，收到3个重复报文段才触发快速重传+快速恢复

**快速重传，快速恢复**

- 立即重传丢失的报文段，ssthresh减半，CWND = ssthresh + 3SMSS
- 收到1个**重复的**ack时，设置CWND += SMSS
> 前面两步理解不能啊，为什么都知道卡了还要发多一点?
- 当收到新的ack时，CWND = ssthresh，至此快速恢复完成，继续拥塞避免

> 确实没太懂。强行理解一下：如果是发送超时了，那说明是一下子发太多了堵住了，赶紧重新从慢的地方开始发，同时降低一下慢启动门限；假如是收到冗余ACK，那说明网络还work，很有可能是某个包丢了，或者是乱序了，那赶紧把缺的包传出去，不要一个包堵住后面所有的
