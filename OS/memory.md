# 内存

> 关于内存的知识暂时都是囫囵吞枣，以后有机会再好好学。

## 基址寄存器; 界限寄存器

每次访问内存都要做加法和比较运算

## 交换

看起来是低级的虚拟内存，因为是整个进程在磁盘和内存间切换；

会造成外部碎片，通过将进程整体“缩”向低位kernel处来消除(内存紧缩)，非常耗时；

数据段需要增长（堆中动态分配内存、压栈等），相邻区域又没空间了，就又要重新交换和分配空间。

TODO: 空闲空间管理，使用位图/链表；首次适配、下次适配、最佳适配、最差适配、快速适配

## 虚拟内存

### 分页

- 内存管理单元(MMU) 进行内存映射; CPU的一部分
- 虚拟地址划分为固定的 page, 物理内存对应 page frame (512bytes --> 1GB，实际上处理器可以支持不同大小page的混合使用)
- 缺页中断

### 页表
- 16位虚拟地址 = 4位虚拟页号(索引页表,可表示16个page) + 12位offset(一页内4096bytes编址)，虚拟页号定位物理页框(如果有的话)，offset对应页框内的偏移量
- 保护位(r/w/exec)
- 脏位、访问位；写入时标记脏位，表示发生置换时要写入磁盘，否则可直接丢弃，访问位用于抉择置换(页面调度算法)

### 加速分页

TODO: TLB转换检测缓冲区(快表)、软件TLB；软失效、硬失效、次要缺页、严重缺页、段错误

### 大内存页表

- 多级页表：简单来说就是从原来一级页表的一个索引变成多个，分别对应多级。32位页面大小位4KB，页面数位2^20(offset=12, pt1=10, pt2=10)
- 倒排页表：页表记录的是物理页框，而不是虚拟页面，使用TLB加速，在64位机器比较常见


## 页面置换算法 

- 最优算法; 要模拟运行一遍程序并作标记，在之后谁用的最少 (可以联想到这对并发程序意义不大); 实际上不会使用
- **NRU; 最近未使用**; R位和M位，R位被定期清零; 用R、W标记四类，先淘汰前面的
  - 没被访问，没被修改
  - 没被访问，已被修改(R被清零是就会变成这种)
  - 已被访问，没被修改
  - 已被访问，已被修改
- FIFO; 比较少用，因为会把最先来的常用的清掉了
- 第二次机会; 在FIFO的基础上，先检查一遍R位，如果为0直接清掉；如果为1，清0R位放队尾
- **时钟页面置换**; 第二次机会合理，但是修改链表开销大; 用环形链表改善
- LRU; 最近最少使用; 实现代价很高，需要维护一个经常更新的链表，最近最多用的为head，最近最少的为tail，每次访问内存都要更新链表; 用空间换时间: 用硬件在每个页表维护一个64bit计数器，每次访问+1，缺页时找到值最小的页(还是很垃圾)
- NFU; 最不常用算法, 软件模拟LRU; 每个时钟count增加页的R值; 缺页时置换最小值
- **老化算法**; 在NFU的基础上， count >> 1 并大端+1; 缺页时仍是置换最小值; 位数有限,无视很久以前的访问
- 工作集页面置换; 进程当前正在使用的页面集合=工作集; 颠簸=每执行几条指令就发生一次缺页中断; 预先调页; (感觉有点像NRU加上一个老化时间)
- 工作集时钟页面置换; TODO

---

## *分页系统中的设计问题

页面大小: 内部碎片; （外部碎片呢）

共享页面：写时拷贝; 共享库(动态链接库)

内存映射文件(mmap)

## 有关实现

缺页中断处理的详细过程 //TODO

## 分段

一个进程还是需要多个独立的地址空间来做不同的事情，以便各自增长而不发生碰撞(符号表、调用堆栈等)

外部碎片

[段页式管理](https://blog.csdn.net/qq_37924084/article/details/78360003)

分段机制和分页机制的区别

1、分页机制会使用大小固定的内存块，而分段管理则使用了大小可变的块来管理内存。

2、分页使用固定大小的块更为适合管理物理内存，分段机制使用大小可变的块更适合处理复杂系统的逻辑分区。

3、段表存储在线性地址空间，而页表则保存在物理地址空间。