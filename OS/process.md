# 进程

> focus on Linux

> 这几天的囫囵吞枣让我明白，首先是得有好的参考；中文原版的现代操作系统不是个好的选择，之后学习该采用英文版；其次是，这么大、涉及很多领域的知识，需要专注而耐心地消化，现在为了面试这么草草地学相当于没有学。

> 既然这么喜欢OS，那就得切实地去做~MIT 6.828，还是得上！这一次要有更多的耐心~

## 进程控制

pid = 0, 交换进程，内核的一部分
pid = 1, `init`进程，`/sbin/init`或`/etc/init`，负责在自举内核后启动一个UNIX系统，是一个用户进程，所有孤儿进程的父进程 (MacOS是`launchd`)

### `fork`

父进程返回子进程pid，子进程中返回0

子进程不再对原进程设置的信号处理函数起作用(信号位图被清除)

写时拷贝（子进程写数据-->缺页中断-->然后os给子进程分配内存并复制父进程的数据）

父进程的fd在子进程默认打开，fd引用计数++(这就是为什么很多时候需要`close-on-exec`)

`vfork` 类似`fork`, 并不复制地址空间, 因为直接执行`exec`

### `exit`

- 正常退出: `return` / `exit`
- 异常终止: 调用`abort` / 收到某些信号 / 最后一个线程对“取消”请求作出响应(???)

### `wait`系列

阻塞地回收子进程，可以选择在接收到SIGCHLD信号的时候调用`wait`，以防阻塞;

`wait`返回回收的子进程的pid

`wait3`, `wait4`, 返回一定的资源统计信息(user cpu, sys cpu, 缺页次数, signal接收次数)

> TODO `waitid`

### `exec`系列

执行其他程序，替换当前进程映像, 当前进程的正文段、数据段、堆段和栈段被替换

exec不会关闭原程序打开的fd; [close-on-exec](https://blog.csdn.net/justmeloo/article/details/40184039)

copy-on-write(硬件支持)

> TODO 各个函数详细对比

### 僵尸进程 & 孤儿进程

子进程运行结束+父进程未读取其退出状态（子进程保留了PCB结构等待父进程回收）。父进程若正常退出而不回收子进程，子进程会被 `init`进程(pid=1)收养，成为孤儿进程。但如果父进程一直不退出（比如循环），那结束的子进程就成为僵尸进程了。
> 孤儿进程和僵尸进程的区别和联系

wait; waitpid;

将 waitpid函数 中 options 设为 WNOHANG, waitpid调用将为非阻塞的; 但如果单用这个非阻塞方法没啥效率提升，要配合 SIGCHLD 的信号，这是子进程退出时给父进程发的。因此可以在父进程捕获SIGCHLD信号，再调用waitpid

> 信号的原理?

SIGSTOP, SIGKILL 信号不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。

父进程接收的信号会传给子进程(存疑)

## C程序存储空间布局

> APUE page164

```
-------
高位地址 --> 命令行参数和环境变量
-------
    栈
    |
    |
    ↓


    ↑
    |
    |
    堆
-------
未初始化数据(bss) ？
-------
初始化数据(即数据段)
-------
程序正文
-------
```
## Linux进程状态

进程的基本状态有：就绪、运行、阻塞，就绪和运行之间的转换是由调度程序执行的。

Linux:
- R(running): 包括了就绪和运行
- S(sleep): 可中断的睡眠(等待IO之类的), 中断信号比如kill
- D: 不可中断睡眠，kill不掉，比如vfork时
- T: 暂停/跟踪状态，暂停比如收到SIGSTOP信号，跟踪比如gdb、
- Z: dead以后的僵尸进程，没被wait回收
- X(exit-dead): 进程即将被销毁(非常短暂难以捕捉)


## 进程的实现

os维护进程表，每个进程占用一个表项，称为进程控制块(PCB, 也称进程表项)
PCB包括了: 程序计数器、堆栈指针、内存分配状况、fd状况、账号和调度信息，以保证进程能从就绪/阻塞中恢复到运行

## 中断的过程

> to be continued. 明天过了线程/内存管理呗，顺便刷刷题~干巴爹

I/O中断向量(靠近内存底部的固定区域)，包含中断服务程序的入口地址。
中断流程：
1. 关闭中断，不再接受新的中断
2. 将当前程序计数器(发生中断处的程序)等压入堆栈
3. 从中断向量中找到中断服务程序

以上三步一般是硬件完成

4. (汇编) 保存现场，给中断让地方，寄存器值放到PCB中
5. (汇编) 设置新的堆栈
6. (C) 执行中断服务程序
7. 调度程序决定下一个将运行的进程
8. (汇编) 开始运行下一个新的进程(不一定是原来那个？) 

> to be continued;