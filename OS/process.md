# 进程

> focus on Linux

**fork**

子进程不再对原进程设置的信号处理函数起作用(信号位图被清除)

写时拷贝（子进程写数据-->缺页中断-->然后os给子进程分配内存并复制父进程的数据）

父进程的fd在子进程默认打开，fd引用计数++

**exec系列**

执行其他程序，替换当前进程映像。exec不会关闭原程序打开的fd
> 真的是完全替换，不返回了吗?那为什么python的os.exec()好像确实返回了

**僵尸进程**

子进程运行结束+父进程未读取其退出状态。父进程结束或异常终止

> 孤儿进程和僵尸进程的区别和联系

wait; waitpid;

将 waitpid函数 中 options 设为 WNOHANG, waitpid调用将为非阻塞的; 但如果单用这个非阻塞方法没啥效率提升，要配合 SIGCHLD 的信号，这是子进程退出时给父进程发的。因此可以在父进程捕获SIGCHLD信号，再调用waitpid

> 信号的原理?

SIGSTOP, SIGKILL 信号不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。

父进程接收的信号会传给子进程(存疑)

## Linux进程状态

进程的基本状态有：就绪、运行、阻塞，就绪和运行之间的转换是由调度程序执行的。

Linux:
- R(running): 包括了就绪和运行
- S(sleep): 可中断的睡眠(等待IO之类的), 中断信号比如kill
- D: 不可中断睡眠，kill不掉，比如vfork时
- T: 暂停/跟踪状态，暂停比如收到SIGSTOP信号，跟踪比如gdb、
- Z: dead以后的僵尸进程，没被wait回收
- X(exit-dead): 进程即将被销毁(非常短暂难以捕捉)


## 进程的实现

os维护进程表，每个进程占用一个表项，称为进程控制块(PCB, 也称进程表项)
PCB包括了: 程序计数器、堆栈指针、内存分配状况、fd状况、账号和调度信息，以保证进程能从就绪/阻塞中恢复到运行

## 中断的过程

> to be continued. 明天过了线程/内存管理呗，顺便刷刷题~干巴爹

I/O中断向量(靠近内存底部的固定区域)，包含中断服务程序的入口地址。
中断流程：
1. 关闭中断，不再接受新的中断
2. 将当前程序计数器(发生中断处的程序)等压入堆栈
3. 从中断向量中找到中断服务程序

以上三步一般是硬件完成

4. (汇编) 保存现场，给中断让地方，寄存器值放到PCB中
5. (汇编) 设置新的堆栈
6. (C) 执行中断服务程序
7. 调度程序决定下一个将运行的进程
8. (汇编) 开始运行下一个新的进程(不一定是原来那个？) 

## 进程间通信

**管道**

**信号量**

**共享内存**

**消息队列**

## 调度算法