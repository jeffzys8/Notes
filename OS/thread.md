# 线程

> focus on Linux

**线程模型**

内核线程(轻量级进程)，运行在内核空间，内核调度
用户线程，用户空间，由线程库调度

内核线程相当于用户线程的“运行容器”。线程实现有三种模式：完全用户空间实现、完全由内核调度、双层调度。
- 完全用户空间实现，对于内核来说最小调度单位为进程，因为内核不知道有线程存在。M个用户空间线程对应1个内核线程(即进程本身)。
不占用额外内核资源，也无需内核干预(很快)，但是一个进程的多个线程无法运行在不同CPU上。(早期伯克利UNIX线程)
- 完全由内核调度，内核控制线程的创建和调度，线程库(用户空间)无需管理任务，在线程管理和同步上需要占用较多资源。用户线程数=内核线程数。（LinuxThreads和NPTL都是这样实现，现代Linux默认使用线程库是NPTL)
- 双层调度模式，前两者的结合

Linux线程库，采用1:1模型（不同进程的线程能共享互斥锁这么厉害~）

pthread_create; pthread_exit; pthread_join; pthread_cancel;
pthread_attr_t

> 插一句：需要复习一下有限状态机，提了好多次了

线程的TCB内容(不确定是不是叫TCB)：
- 程序计数器
- 寄存器
- 堆栈(每个线程自己会调用不同的函数，所以要记录)
- 状态
- **没有** 地址空间、全局变量、fd、子进程、定时器、信号、账户信息，**因为这些是进程的**

线程的“难题”
- fork时是否要复制线程
- 如果复制了，父进程某个线程的read是否要让子进程同样的线程一起阻塞
- 地址空间增大时发生了线程切换，然后新运行线程也请求了扩大空间?

## 线程同步

posix信号量

互斥锁

条件变量

## 死锁